## Part II: Expression Parsing

### Files
* **`cradle.py`:** The main program that coordinates the execution of the compiler.
* **`llvm.py`:** A helper class for generating LLVM Intermediate Representation (IR) code.
* **`code_processor.py`:** Handles expression parsing, implemented in the previous chapter.
* **`scanner.py`:** Processes the source code by reading it character by character.
* **`test_1_expression.txt`, `test_200_expression.txt`:** Example expressions to test the expression handling functionality.
* **`build_and_run.sh`:** A script to compile and execute the LLVM IR code generated by `cradle.py`.
  Example usage:
  ```bash
  ./build_and_run.sh test_1_expression
  ./build_and_run.sh test_200_expression

### Detailed Steps for Manual Compilation and Execution
**1. Generate LLVM IR Code**
```bash
python cradle.py test_1_expression.txt --M68k test_1_expression.m68k.asm --LLVM test_1_expression.ll
```
**2. Compile LLVM IR to Bitcode**

Use `opt` to compile the LLVM IR code to bitcode. Adjust the optimization level (`--O0` to `--O3`) as needed:
```bash
opt --O0 test_1_expression.ll -o test_1_expression.bc
```

**3. Compile Bitcode to Assembly Code**

Use `llc` to compile the bitcode to assembly code. Adjust the optimization level (`-O0` to `-O3`) as needed:
```bash
llc -filetype=asm -O0 -relocation-model=pic test_1_expression.bc -o test_1_expression.asm
```
**4. Compile Bitcode to Mainframe Assembly Code (optional)**

For Mainframe developers, the LLVM IR code can be compiled into Mainframe assembly language. Specify the `systemz` architecture:
```bash
llc -filetype=asm -O0 -march=systemz -relocation-model=pic test_1_expression.bc -o test_1_expression.systemz.asm
```
**5. Compile Assembly Code to Executable**

Use `clang` to compile the assembly code into an executable:
```bash
clang test_1_expression.asm -o test_1_expression
```
**6. Run the Executable**

Execute the compiled program:
```bash
./test_1_expression
```
**7. Check the Output**

The following output will be generated from the input file, which is a CSV file. The columns represent:

1. **Counter:** Serial number.
2. **Expected:** The result calculated by Python.
3. **Current:** The result calculated by the generated LLVM IR code.

**Example Output:**
```csv
counter;expected;current
1;38;38
```
### Notes for LLVM IR version
#### Static Single Assignment (SSA) variables

In compiler design, [static single assignment form](https://en.wikipedia.org/wiki/Static_single-assignment_form) (often abbreviated as SSA form or simply SSA) is a type of intermediate representation (IR) where each variable is assigned exactly once.

#### The expression `3+5*7` in different targets

<table>
  <tr>
    <th>Motorola 68000</th>
    <th>LLVM IR</th>
  </tr>
  <tr>
    <td>
      <pre><code class="asm">
MOVE #3, D0      ; D0 = 3
MOVE D0,-(SP)    ; push D0 onto stack
MOVE #5, D0      ; D0 = 5
MOVE D0,-(SP)    ; decrement SP; (SP)=D0 (push)
MOVE #7, D0      ; D0 = 7
MULS (SP)+,D0    ; D0 *= (SP); increment SP (pop)
ADD (SP)+,D0     ; D0 += (SP); increment SP (pop)
      </code></pre>
    </td>
    <td>
      <pre><code class="asm">
%ssa_0 = add i32 3, 0          ; %ssa_0 = 3
%stack_0 = add i32 %ssa_0, 0
%ssa_1 = add i32 5, 0          ; %ssa_1 = 5
%stack_1 = add i32 %ssa_1, 0   ; %stack_1 = %ssa_1
%ssa_2 = add i32 7, 0          ; %ssa_2 = 7
%ssa_3 = mul i32 %stack_1, %ssa_2
%ssa_4 = add i32 %stack_0, %ssa_3
      </code></pre>
    </td>
</table>

In LLVM IR, SSA (Static Single Assignment) variables are used instead of registers and the stack.

There is no direct instruction for simple assignment to an SSA variable in LLVM IR. To _assign a constant to an SSA variable, you can use an operation like the `add` instruction_. For example: `%ssa_0 = add i32 3, 0`.

When compiling to a specific CPU's assembly language, the usage of SSA variables is translated into the target architecture's constructs, taking full advantage of its capabilities.

Since we emit LLVM IR code, we don't have to worry too much about optimization. Because the whole expression is evaluated at compile time, when compiling this simple expression with optimization level `-O1`, the expression is converted into a single statement for the target CPU: `movl $38, %ecx`.

#### Truncating and Floor Division

**Explanation:**
- **Truncating Division** (Used in Java, C, Assembly, and Many Other Programming Languages): The result of dividing two integers is always rounded towards zero. Consequently, negative results are rounded towards zero, rather than down to the next lower integer.
```java
System.out.println(7 / 3);   // Output: 2 (truncating division)
System.out.println(-7 / 3);  // Output: -2 (truncating division)
```
- **Floor Division** (Python): The result is rounded down towards negative infinity. This is useful for cases where you want the result to always round downward when working with negative numbers.
```python
print(7 / 3)   # Output: 2.3333333333333335 (float)
print(7 // 3)  # Output: 2 (integer floor division)
print(-7 // 3) # Output: -3 (integer floor division)
```
By implementing the floor_div function in LLVM IR, I ensure that the behavior of division in the compiled code matches Python's floor division, providing a more predictable result, especially for negative numbers.

Java's Math.floorDiv() logic:
```java
public static int floorDiv(int x, int y) {
    int r = x / y;
    // if the signs are different and modulo not zero, round down
    if ((x ^ y) < 0 && (r * y != x)) {
        r--;
    }
    return r;
}
```
Function for floor division in LLVM IR:
```asm
define i32 @floor_div(i32 %x, i32 %y) alwaysinline {
    %q = sdiv i32 %x, %y
    %q_mul_y = mul i32 %q, %y
    %remainder = sub i32 %x, %q_mul_y
    %xor_result = xor i32 %x, %y
    %sign_diff = icmp slt i32 %xor_result, 0
    %non_zero_remainder = icmp ne i32 %remainder, 0
    %round_down_condition = and i1 %sign_diff, %non_zero_remainder
    %q_minus_1 = sub i32 %q, 1
    %final_result = select i1 %round_down_condition, i32 %q_minus_1, i32 %q
    ret i32 %final_result
}
```
#### Known Issue
The unary `-` and `+` operators are not fully implemented. Their handling will be addressed in Part VI, so these operators were not tested in this chapter.
