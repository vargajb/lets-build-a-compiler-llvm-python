## Part III: More Expressions

[Part 3 of Jack W. Crenshaw's "Let's Build a Compiler!" series](https://xmonader.github.io/letsbuildacompiler-pretty/tutor03_moreexpressions.html) focuses on enhancing the parser to handle variables, function calls, assignment statements, multi-character tokens, and embedded white spaces. These improvements make the parser more versatile and closer to a practical language compiler.

Key advancements include:

**1. Variables:**
* Extending the parser to handle variables as factors in expressions.
* Adding support for variable referencing and position-independent code generation.

**2. Function Calls:**
* Introducing simple function calls (e.g., `x()`), using branching statements (e.g., `BSR`).
* Handling ambiguity between variables and functions by utilizing lookahead.

**3. Assignment Statements:**
* Implementing the parsing and translation of assignment statements (e.g., `a = b + c`).
* Generating appropriate assembly code for assignment.

**4. Multi-Character Tokens:**
* Transitioning from single-character tokens to multi-character ones, supporting longer variable names and numbers.
* Adjusting the parserâ€™s lexical recognition for identifiers and numbers.

**5. Embedded White Spaces:**
* Modifying the parser to skip and ignore white spaces for more flexible input handling.

**6. Error Handling:**
* Discussing robust techniques for managing malformed expressions.
* Ensuring the parser correctly flags errors while maintaining simplicity in design.

**7. Code Optimization:**
* Streamlining parsing operations by using structured BNF notation.
* Minimizing complexity in assembly code generation.

The chapter concludes by emphasizing the adaptability of recursive descent parsing for complex language features. It prepares readers for future topics, such as interpreters, by showcasing how changes in functionality affect parser structure.

---

### Files
* **`cradle.py`:** The main program that coordinates the execution of the compiler.
* **`llvm.py`:** A helper class for generating LLVM Intermediate Representation (IR) code.
* **`code_processor.py`:** Handles expression parsing, implemented in the previous chapter.
* **`scanner.py`:** Processes the source code by reading it character by character.
* **`build_and_run.sh`:** A script to compile and execute the LLVM IR code generated by `cradle.py`.
* **`test_expressions.txt`:** Example expressions to test the expression handling functionality.
* **`test_expressions.ll`, `test_expressions.m68k.asm`:** Generated LLVM IR and Motorola 68000 assembly code from `test_expressions.txt`.

---

### Steps for Compilation and Execution

**Step 1: Generate LLVM IR and Motorolla 68000 Code**
```bash
python cradle.py test_expressions.txt --M68k test_expressions.m68k.asm --LLVM test_expressions.ll
```
**Step 2: Compile and Execute LLVM IR Code**

Use this script to compile and execute:
```bash
./build_and_run.sh test_expressions
```
**Step 3: Input and Output Example**

Below is an example of the input file and its corresponding output after processing:

This example demonstrates how the parser handles variables, expressions, and assignments while generating correct output for both LLVM IR and assembly code.

<table>
  <tr>
    <th>Input: test_expressions.txt</th>
    <th>Output</th>
  </tr>
  <tr>
    <td>
      <pre><code class="c">
a1 = 3
a2 = 7 + a1 * 5
bb = a2 / a1
bb2 = a2 / (0 - a1)
bb3 = bb - bb2
      </code></pre>
    </td>
    <td>
      <pre><code class="c">
A1 = 3
A2 = 22
BB = 7
BB2 = -8
BB3 = 15
      </code></pre>
    </td>
</table>
